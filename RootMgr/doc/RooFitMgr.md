# `mgr::RooFitMgr` Class
In analysis, you might also want to declare multiple dataset and pdfs for each sample, dataset with the same weight (scaled-up, scaled-down) applied and their corresponding fitting results and the such. This class allows you pass the onwership of `RooFit` objects to the `RooFitMgr` class for easier analysis code. See the following example code:

```
main()
{
   // Declaring global variables for all samples
   RooFitMgr::StaticNewVar( "x" , "x" , "GeV/c" , -10 , 10 );

   vector<RooFitMgr*> samplelist;
   samplelist.push_back( new RooFitMgr("sample1") );
   samplelist.push_back( new RooFitMgr("sample2") );

   for( auto& mgr : samplelist ) {
      fill(mgr);
   }
   for( auto& mgr : samplelist ) {
      fit(mgr);
   }

   RooPlot* frame = x.frame();

   for( auto& mgr : samplelist ) {
      // Dataset "test" generated by fill function
      mgr->DataSet("test")->plotOn( frame );

      // Pdf "gauss" generated by fit function;
      mgr->Pdf("gauss")->plotOn( frame );

      // Variable  also generated by fit function
      cout << mgr->Var("mean")->getVal() << " "
           << mgr->Var("sig")->getVal() << endl;
   }
}

fill( RooFitMgr* mgr )
{
   //Declaring data set outside of class
   RooDataSet* x  = RooFitMgr::Var("x");
   RooDataSet* dataset = new DataSet("test","", RooArgSet(*x) );

   // Filling dataset
   for( something ) { *x = somthing ; dataset->fill(x);  }

   // Passing ownership to managerclass
   mgr->AddDataSet( dataset );
}

fit( RooFitMgr* mgr )
{
   // Fitting results variable should be unique to this sampe
   RooRealVar* x    = RooFitMgr::Var("x");
   RooRealVar* mean = mgr->NewVar( "mean", 0, -5, 5 );
   RooRealVar* sig  = mgr->NewVar( "sig" , 1,  0, 5 );

   // Declaring pdf object outside class
   RooGaussian* gauss =  new RooGaussian( "guass" , "",  *x, *mean, *sig );

   // fitting to previously filled dataset
   guass.fitTo( *(mgr->DataSet("test")) );   

   // passing ownership to manager class
   mgr->AddPdf( gauss ) ;
}
```
This is of course, a very loose frame work. How to expose the existing the existing dataset among function needs to be handed by the user. There is aiding function to help check if certain variable/dataset/pdfs with the corresponding names exist.

## `RooRealVar` access functions
`RooRealVar` instances that are unique to the a class instance are required to be declared directly by the `NewVar` function. Notice that compared with default declaration of `RooRealVar`, there is one missing string, beacuse by default we set the variable title to be a blank string. The name placed as the first argument will could later be used for the access of instance by the `Var(std::string)` function.

Notice in the case that a name already in use within the manager class. It will overwrite the properties of the existing variable with the new setting.

There are addtional special access functions:

* `std::vector<std::string> VarNameList()`: returns an exhaustive list of all associated name stored in our manager class
* `std::vector<RooRealVar*> VarContains( const std::string& x )`: returns a list of `RooRealVar` pointers where their associated name has `x` as a substring. Useful if we you intend of mass declaring variables with common string patterns.

Only the first of this function will have a static counterpart.

For the static variables, the declarations are a bit different where we reqired:
* The string for the associated name
* A string for the title of the variable
* A string for the unit of the varaible
* the minimum and maximum value. No initial value allowed.
This is because this variable are typically used for plotting and not just calculation.


## `RooDataSet` access functions
Since the declaration of dataset would require specific subsets of the static `RooRealVars`, We will not provide a way of directly declaring a dataset under the ownership of the manager class. Instead, users are required to declare a `RooDataSet` object separately and pass ownership by the method `AddDataSet(RooDataSet*)`. The associative name will be taken directly from the `RooDataSet->GetName()` method. In the case the associative name is already taken in the manager class, the previous instance of the dataset will be removed.

Similar with the `RooRealVar` there will be a function for dumping all of the possible names:

* `std::vector<std::string> SetNameList()`

Since `RooDataSet` are potentially very large, and Monte-Carlo studies might require multiple generated RooDataSet, we add the function of `RemoveDataSet(string)` to allow for `RooDataSet` removal.


## `RooAbsPdf` access functions
Because the declaration of PDf function greatly depends on the PDF one is interested in, we won't provide a way od directly delcaring a pdf object under the ownership of the manager class. Instead, the user is required to declare a PDF object separately and pass the ownership by the `AddPdf(RooAbsPdf*)` method. The associated name will be take directly from the `RooAbsPdf->GetName()` method. In the case the associative name is already take in the manager class, the preivous instance of the PDF object will be removed.  
